#include <windows.h>
#include <stdio.h>

__declspec(dllexport) int __stdcall suma(int a, int b) {
	return a + b;
}

__declspec(dllexport) int __stdcall resta(int a, int b) {
	return a - b;
}

//Metodo para generar un numero random dentro de ASM
__declspec(dllexport) int __stdcall generadorNumeroRandom() {

	int numeroGenerado;

	//rdtsc lee el tiempo de ejecucion del CPU en edx:eax, luego se mezclan bits de edx con eax.
	//Movemos 10 a ecx que sera nuestro maximo(realmente 9 por la operacion) y se divido eax entre
	//ecx es decir eax/10.

	//Ya por ultimo se mueve el residuo a numeroGenerado.
	__asm {
		rdtsc
		xor edx, eax
		xor edx, edx
		mov ecx, 10
		div ecx
		mov numeroGenerado, edx
	}

	return numeroGenerado;
}

//Metodo para verificar la dificultad del juego
__declspec(dllexport) int __stdcall verificarDificultad(char* dificultad) {

	//Se crean las variables necesarias, es decir la dificultad final(dependiendo de la dificultad identificada se asingara un valor)
	//ademas los arreglos de cada dificultad para poder compararla.
	int nuevaDificultad;
	char facil[] = "Facil";
	char normal[] = "Normal";
	char dificil[] = "Dificil";

	//Basicamente se asigna al inicio el -1 para dejar definido que no se encontro, pero con las comparaciones si una de los tres 
	//es igual entonces se cambia a otro numero entero

	//Se mueve el puntero de dificultad a un registro para recorrer y tambien la dificultad base para comparar en otro registro.

	//Mete los caracteres del mismo indice a registos y los compara, si son iguales entonces sigue recorriendo hasta encontrar el 0 es decir
	//caracter nulo

	//Si no coinciden con un solo caracter quiere decir que no son iguales, por lo tanto pasa a compara con otra dificultad, ya al ultimo que no
	//es igual a la ultima dificultad simplemente termina el codigo de ASM.

	//Si son iguales se asigna un nuevo valora dificultad mediante dirigiendolo a la etiqueta correspondiente
	__asm {

		mov nuevaDificultad, -1

		TESTFACIL:
		mov esi, dificultad
			lea edi, facil

			CICLO1 :
		mov al, [esi]
			mov bl, [edi]
			cmp al, bl
			jne TESTNORMAL

			cmp al, 0
			je IGUALESFACIL
			inc esi
			inc edi

			jmp CICLO1

			TESTNORMAL :
		mov esi, dificultad
			lea edi, normal

			CICLO2 :
		mov al, [esi]
			mov bl, [edi]
			cmp al, bl
			jne TESTDIFICIL


			cmp al, 0
			je IGUALESNORMAL
			inc esi
			inc edi


			jmp CICLO2

			TESTDIFICIL :
		mov esi, dificultad
			lea edi, dificil

			CICLO3 :
		mov al, [esi]
			mov bl, [edi]
			cmp al, bl
			jne FIN

			cmp al, 0
			je IGUALESDIFICIL
			inc esi
			inc edi

			jmp CICLO3

			IGUALESFACIL :
		mov nuevaDificultad, 1
			jmp FIN

			IGUALESNORMAL :
		mov nuevaDificultad, 2
			jmp FIN

			IGUALESDIFICIL :
		mov nuevaDificultad, 3
			jmp FIN

			FIN :
	}

	return nuevaDificultad;
}

//Funcion para obtener la palabra con el indice generado y la dificultad identificada
__declspec(dllexport) char* __stdcall obtenerPalabra(char* banco[], int index) {

	//Se asgina null a la variable donde se asignara la palabra para no generar errores
	char* palabraSeleccionada = NULL;

	//Consiste en primero verificar si el indice ingresado es valido, primero moviendo el indice a eax y se compara,
	//sino simplemente se mete un cero a palabraSelccionada

	//Ahora se mete a esi el puntero del arreglo y mediante la suma del puntero(ubicacion en memoria con el indice multplicado por cuatro por que cada char* vale 4 bytes)
	//se obtiene la palabra del arreglo, ahora simplemente se mueve esa ubicacion en palabraSeleccionada para posteriormente regresarla
	__asm {
		mov eax, index
		cmp eax, 9
		ja FUERA

		mov esi, banco
		mov eax, [esi + eax * 4]
		mov palabraSeleccionada, eax
		jmp FIN

		FUERA :
		mov palabraSeleccionada, 0

			FIN :
	}

	return palabraSeleccionada;
}

//Funcion que cuenta las letras de una palabra
__declspec(dllexport) int __stdcall cantidadLetrasPalabra(char* palabra) {

	//Se crea la variable que almacenara la cantidad de palabras
	int cantidadLetras = 0;

	//Mueve la ubicacion de memoria a esi para iterar.
	//Limpia ecx para empezar a contar.
	//Cuando empieza el ciclo, recorre cada elemento, si llega a cero quiere decir que es el caracter nulo
	//por lo tanto se dirige a otra etiqueta, ademas sino es igual a cero, se incrementa ecx y esi para la siguiente iteracion
	__asm {
		mov esi, palabra
		mov ecx, 0

		CONTADOR:
		mov al, [esi]

			cmp al, 0
			je ACABO

			inc esi
			inc ecx
			jmp CONTADOR

			ACABO :
		mov cantidadLetras, ecx
	}


	return cantidadLetras;
}

//Metodo que verifica los espacios verde con el arreglo booleano DAB
__declspec(dllexport) int* __stdcall verificarVerdes(char* palabraUsuario, char* palabraAdivinar, int cantidadLetras) {
	int* arregloVerdes = (int*)calloc(cantidadLetras, sizeof(int));
	int indice = 0;

	__asm {
		mov ecx, arregloVerdes;
		mov edx, indice
		mov esi, palabraUsuario
		mov edi, palabraAdivinar

		//voy comparando letra por letro y me voy moviendo en la palabra con el edx que es el indice
		ciclo1:
			mov al, [esi + edx]
			mov bl, [edi + edx]
			cmp al, bl
			jne noIgual
			mov dword ptr[ecx + edx * 4], 1

		noIgual:
			inc edx
			cmp edx, cantidadLetras
			jl ciclo1
	}

	return arregloVerdes;
}

//Metodo que verifica los espacios amarillos con un arreglo booleano 
__declspec(dllexport) int* __stdcall verificarAmarillos(char* palabraUsuario, char* palabraAdivinar, int cantidadLetras) {
	int* arregloAmarillos = (int*)calloc(cantidadLetras, sizeof(int));
	int indice = 0;

	__asm {
		mov ecx, arregloAmarillos
		mov esi, palabraUsuario
		mov edi, palabraAdivinar
		mov ebx, indice                  

		ciclo1:
			cmp ebx, cantidadLetras
			jge fin                       

			mov al, [esi + ebx]          
			mov edx, 0                 

			ciclo2:
				cmp edx, cantidadLetras
				jge siguiente                

				cmp ebx, edx               
				je noIgual                   

				mov ah, [edi + edx]         
				cmp al, ah                   
				jne noIgual                  

			
				mov dword ptr[ecx + ebx * 4], 1  
				jmp siguiente                

		noIgual:
			inc edx                     
			jmp ciclo2

		siguiente:
			inc ebx                      
			jmp ciclo1

			fin :
	}
	return arregloAmarillos;
}

//Funcion que verificar si el usuario ingreso la palabra correcta
__declspec(dllexport) int __stdcall verificarVictoria(int* arregloVerdes, int cantidadLetras) {

	int banderaRetornada = 1;

	//Apunto el arreglo a esi y ecx sera el contador que verifica si llego al limite del arreglo.
	//Estara comprobando en cada elemento si hy un cero. Si lo hay cambia la bandera a cero y por lo
	//tanto no ha ganado.
	__asm {
		mov esi, arregloVerdes
		mov ecx, 0
		mov edx, cantidadLetras

		COMPROBACIOUNOS:
			cmp ecx, edx
			je FINAL2

			mov eax, [esi]

			cmp eax, 1
			jne FINAL

			add esi, 4
			inc ecx
			jmp COMPROBACIOUNOS

		FINAL:
			mov banderaRetornada, 0	
				
		FINAL2:
	}

	return banderaRetornada;
}

//Funcion que regresa el tiempo de ejecucion actual del sistrma
__declspec(dllexport) long __stdcall obtenerTiempo() {

	long tiempo = 0;

	//Llamamos la funcion GetTickCount que nos da el tiempo de ejecucion actual.

	//Lo mete en eax, por lo tanto movemos eax a la variable que se retornara.
	__asm {
		call GetTickCount
		mov tiempo, eax
	}

	return tiempo;
}

//Funcion para saber si ya hizo los 6 intentos. Si los hizo quiere decir que puede que perdio(puede que el ultimo intento haya ganado
// pero por esto mismo se verifica antes si gano)
__declspec(dllexport) int verificarDerrota(int intentos) {
	
	int banderaRetornada = 0;

	__asm {
		mov ecx, intentos

		cmp ecx, 6
		je FINAL
		jmp NOFINAL

		FINAL:
			mov banderaRetornada, 1

		NOFINAL:
	}

	return banderaRetornada;
}

//Funcion que permite convertir los milisegundo y tiempo absoluto en segundos de tipo int
__declspec(dllexport) int operacionTiempou(int tiempoFinal, int tiempoInicio) {

	int tiempoSegundos = -1;

	__asm {
		mov eax, tiempoFinal
		sub eax, tiempoInicio
		xor edx, edx

		mov ecx, 1000
		div ecx

		mov tiempoSegundos, eax

	}

	return tiempoSegundos;
}

//Funcion para saber si es mayor a uno el tamanio actual de lineas del archivo
__declspec(dllexport) int verificarTamanioArc(int tiempoActual) {

	int mayor;

	__asm {
		mov eax, tiempoActual
		cmp eax, 0
		jg MAYOR
		jmp SALIDA

		MAYOR:
			mov mayor, 1
			jmp SALIDA

		NOMAYOR:
			mov mayor, 0

		SALIDA:
	}

	return mayor;
}

//Funcion que verifica el tamanio de un arreglo
__declspec(dllexport) int lineasDisponibles(int tamanioActual) {

	int hayQueLeer;

	__asm {
		mov hayQueLeer, 0
		
		mov eax, tamanioActual
		cmp eax, 0
		jg MAYOR

		jmp SALIDA

		MAYOR:
			mov hayQueLeer, 1

		SALIDA:
	}

	return hayQueLeer;
}

__declspec(dllexport) void ordenamientoPuntuaciones(int* tiempos, char** nombres, int n)
{
	//Basicamente ordenamos solamente los tiempos, pero los nombres se mueven en base al ordenamiento de tiempos, por lo tanto
	//se ordenan en paralelo pero simplement nombres se mueve en las mismas posiciones que tiempos.

	//Se utiliza una especie de bubbleSort donde obtenemos los datos mediante saber cuandos bytes corresponden cada dato para
	//cada iteacion moverse el nuevo elemento correctamente
	__asm {
		mov esi, tiempos
		mov edi, nombres
		mov ecx, n

		cmp ecx, 2
		jl FIN

		dec ecx

		PASADA:
			push ecx
			mov ecx, n
			dec ecx
			xor ebx, ebx

			COMPARAR:
				mov eax, [esi + ebx * 4]
				mov edx, [esi + ebx * 4 + 4]

				cmp eax, edx
				jle siguiente

				mov[esi + ebx * 4], edx
				mov[esi + ebx * 4 + 4], eax

			
				mov eax, [edi + ebx * 4]
				mov edx, [edi + ebx * 4 + 4]
				mov[edi + ebx * 4], edx
				mov[edi + ebx * 4 + 4], eax

			SIGUIENTE:
				inc ebx
				dec ecx
				jnz COMPARAR

				pop ecx
				dec ecx
				jnz PASADA

		FIN:
	}
}

//Funcion que calcula el tiempo absoluto en segundos
__declspec(dllexport) int calculoTiempo(int tiempoInicio, int tiempoFinal) {

	int tiempoAbsoluto;

	__asm {
		mov tiempoAbsoluto, 0

		mov eax, tiempoFinal
		sub eax, tiempoInicio
		mov tiempoAbsoluto, eax
	}





